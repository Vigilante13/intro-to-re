# Tools
In this section I'm going to cover various tools that software/hardware engineers use when attempting to reverse engineering a piece of code.

## Disassemblers 
A diassembler is a tool that breaks down a compiled program from any high or low-level programming language and turns it into machine code, or assembly.

### List of Disassemblers
- IDA
- Binary Ninja
- GNU Debugger (GDB)
- radare2
- Hopper

### Assembly/Machine Code
Machine Code or Assembly is code which has been formatted for direct execution by a CPU. Different compilers compile our code into varying machine code for specific Computer Architectures. 

Examples of Architectures include: 
- AMD 
- Windows 
- PowerPC

Going back to our C program in the previous section:

```c
#include <unistd.h>
#include <stdio.h>
#include <stdint.h>

int secret_function(int input) {
    return (((input >> 2) - 1) ^ 48);
}

int main() {
    int x;
    printf("Please enter a number to check:\n");
    printf("> ");
    scanf("%d", &x);
    if (secret_function(x) == 91) {
        printf("Congrats! You got it!\n");
    } else {
        printf("Nope. Sorry...\n");
    }
}
```

If we compile this program for a Linux-64bit distribution, we get the following machine code:

```asm
secret_function(int):
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
        mov     eax, DWORD PTR [rbp-4]
        sar     eax, 2
        sub     eax, 1
        xor     eax, 48
        pop     rbp
        ret
.LC0:
        .string "Please enter a number to check:"
.LC1:
        .string "> "
.LC2:
        .string "%d"
.LC3:
        .string "Congrats! You got it!"
.LC4:
        .string "Nope. Sorry..."
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     edi, OFFSET FLAT:.LC0
        call    puts
        mov     edi, OFFSET FLAT:.LC1
        mov     eax, 0
        call    printf
        lea     rax, [rbp-4]
        mov     rsi, rax
        mov     edi, OFFSET FLAT:.LC2
        mov     eax, 0
        call    scanf
        mov     eax, DWORD PTR [rbp-4]
        mov     edi, eax
        call    secret_function(int)
        cmp     eax, 91
        sete    al
        test    al, al
        je      .L4
        mov     edi, OFFSET FLAT:.LC3
        call    puts
        jmp     .L5
.L4:
        mov     edi, OFFSET FLAT:.LC4
        call    puts
.L5:
        mov     eax, 0
        leave
        ret
```

If you would like to know more about assembly, [this site](https://ctf101.org/reverse-engineering/what-is-assembly-machine-code/) gives a good introduction to x86 and x86-64 archs.

[Godbolt](https://godbolt.org/) shows the differences in machine code generated by various compilers.
