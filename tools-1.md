# Tools
In this section I'm going to cover various tools that software/hardware engineers use when attempting to reverse engineering a piece of code.

## Disassemblers 
A diassembler is a tool that breaks down a compiled program from any high or low-level programming language and turns it into machine code, or assembly.

### List of Disassemblers
- IDA
- Binary Ninja
- GNU Debugger (GDB)
- radare2
- Hopper

### Assembly/Machine Code
Machine Code or Assembly is code which has been formatted for direct execution by a CPU. Different compilers compile our code into varying machine code for specific Computer Architectures. 

Examples of Architectures include: 
- AMD 
- Windows 
- PowerPC

Going back to our C program in the previous section:

```c
#include <unistd.h>
#include <stdio.h>
#include <stdint.h>

int secret_function(int input) {
    return (((input >> 2) - 1) ^ 48);
}

int main() {
    int x;
    printf("Please enter a number to check:\n");
    printf("> ");
    scanf("%d", &x);
    if (secret_function(x) == 91) {
        printf("Congrats! You got it!\n");
    } else {
        printf("Nope. Sorry...\n");
    }
}
```

If we compile this program for a Linux-64bit distribution, we get the following machine code:

```nasm
secret_function(int):
        push    rbp
        mov     rbp, rsp
        mov     DWORD PTR [rbp-4], edi
        mov     eax, DWORD PTR [rbp-4]
        sar     eax, 2
        sub     eax, 1
        xor     eax, 48
        pop     rbp
        ret
.LC0:
        .string "Please enter a number to check:"
.LC1:
        .string "> "
.LC2:
        .string "%d"
.LC3:
        .string "Congrats! You got it!"
.LC4:
        .string "Nope. Sorry..."
main:
        push    rbp
        mov     rbp, rsp
        sub     rsp, 16
        mov     edi, OFFSET FLAT:.LC0
        call    puts
        mov     edi, OFFSET FLAT:.LC1
        mov     eax, 0
        call    printf
        lea     rax, [rbp-4]
        mov     rsi, rax
        mov     edi, OFFSET FLAT:.LC2
        mov     eax, 0
        call    scanf
        mov     eax, DWORD PTR [rbp-4]
        mov     edi, eax
        call    secret_function(int)
        cmp     eax, 91
        sete    al
        test    al, al
        je      .L4
        mov     edi, OFFSET FLAT:.LC3
        call    puts
        jmp     .L5
.L4:
        mov     edi, OFFSET FLAT:.LC4
        call    puts
.L5:
        mov     eax, 0
        leave
        ret
```

If you would like to know more about assembly, [this site](https://ctf101.org/reverse-engineering/what-is-assembly-machine-code/) gives a good introduction to x86 and x86-64 archs.

[Godbolt](https://godbolt.org/) shows the differences in machine code generated by various compilers.

### Diassembling with GDB

Using our example from before, this is how you would use `GDB` to diassembly the function `secret_function` in our program:

```gdb
varuniyer@VarunPC:/mnt/c/Users/vi021/Desktop$ gdb example
GNU gdb (Debian 8.1-4+b1) 8.1
Copyright (C) 2018 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from example...(no debugging symbols found)...done.
(gdb) disas secret_function
Dump of assembler code for function secret_function:
   0x0000000000001155 <+0>:     push   %rbp
   0x0000000000001156 <+1>:     mov    %rsp,%rbp
   0x0000000000001159 <+4>:     mov    %edi,-0x4(%rbp)
   0x000000000000115c <+7>:     mov    -0x4(%rbp),%eax
   0x000000000000115f <+10>:    sar    $0x2,%eax
   0x0000000000001162 <+13>:    sub    $0x1,%eax
   0x0000000000001165 <+16>:    xor    $0x30,%eax
   0x0000000000001168 <+19>:    pop    %rbp
   0x0000000000001169 <+20>:    retq
End of assembler dump.
(gdb)
```

